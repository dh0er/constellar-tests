name: Run All Tests

on:
    workflow_dispatch:
        inputs:
            ref:
                description: "Branch or tag to run on (default: current ref)"
                required: false
                default: ""

permissions:
    contents: read
    actions: write

jobs:
    dispatch:
        name: Dispatch all test workflows
        runs-on: ubuntu-slim
        timeout-minutes: 180
        strategy:
            fail-fast: false
            matrix:
                workflow_file:
                    - tests-ios.yml
                    - tests-android.yml
                    - tests-web.yml
                    - tests-macos.yml
                    - tests-windows.yml
                    - tests-linux.yml
        steps:
            - name: Trigger and wait for ${{ matrix.workflow_file }}
              id: dispatch_and_wait
              uses: actions/github-script@v7
              with:
                  github-token: ${{ secrets.GITHUB_TOKEN }}
                  script: |
                      const workflow_id = "${{ matrix.workflow_file }}";
                      const refInput = "${{ inputs.ref }}".trim();
                      const ref = refInput || context.ref.replace(/^refs\/(heads|tags)\//, "");

                      const dispatchStartedAtMs = Date.now();
                      // Resolve the requested ref to an immutable commit SHA so:
                      // - all dispatched workflows run the exact same commit
                      // - we can reliably discover the created workflow run via head_sha
                      let targetSha = context.sha;
                      if (refInput) {
                        const commit = await github.rest.repos.getCommit({
                          owner: context.repo.owner,
                          repo: context.repo.repo,
                          ref: refInput,
                        });
                        targetSha = commit.data.sha;
                      }

                      core.info(`Dispatching ${workflow_id} on ref=${ref} (targetSha=${targetSha})`);

                      await github.rest.actions.createWorkflowDispatch({
                        owner: context.repo.owner,
                        repo: context.repo.repo,
                        workflow_id,
                        ref: targetSha,
                      });

                      const sleep = (ms) => new Promise((resolve) => setTimeout(resolve, ms));
                      const deadlineMs = dispatchStartedAtMs + (170 * 60 * 1000);

                      // Find the workflow run that was created by the dispatch.
                      // Note: createWorkflowDispatch does not return the run_id, so we discover it by:
                      // - workflow file name (workflow_id)
                      // - event=workflow_dispatch
                      // - head_sha matches this workflow's sha
                      // - created_at after we dispatched (with small slack)
                      let run = null;
                      while (!run && Date.now() < deadlineMs) {
                        const runs = await github.rest.actions.listWorkflowRuns({
                          owner: context.repo.owner,
                          repo: context.repo.repo,
                          workflow_id,
                          event: "workflow_dispatch",
                          per_page: 20,
                        });

                        const candidates = (runs.data.workflow_runs || [])
                          .filter((r) => r && r.head_sha === targetSha)
                          .filter((r) => new Date(r.created_at).getTime() >= (dispatchStartedAtMs - 60_000))
                          .sort((a, b) => new Date(b.created_at) - new Date(a.created_at));

                        run = candidates[0] || null;
                        if (!run) {
                          core.info(`Waiting for ${workflow_id} run to appear...`);
                          await sleep(5000);
                        }
                      }

                      if (!run) {
                        core.setOutput("workflow_file", workflow_id);
                        core.setOutput("ref", ref);
                        core.setOutput("target_sha", targetSha);
                        core.setOutput("run_id", "");
                        core.setOutput("run_url", "");
                        core.setOutput("conclusion", "timed_out");
                        core.setOutput("status", "completed");
                        core.warning(`Timed out discovering run for ${workflow_id} (ref=${ref}, targetSha=${targetSha}).`);
                        return;
                      }

                      core.info(`Discovered run id=${run.id} url=${run.html_url}`);
                      core.setOutput("workflow_file", workflow_id);
                      core.setOutput("ref", ref);
                      core.setOutput("target_sha", targetSha);
                      core.setOutput("run_id", String(run.id));
                      core.setOutput("run_url", run.html_url);

                      // Wait for it to complete. We do NOT fail this step directly; we capture
                      // status/conclusion as outputs so we can download full logs before failing.
                      while (Date.now() < deadlineMs) {
                        const runRes = await github.rest.actions.getWorkflowRun({
                          owner: context.repo.owner,
                          repo: context.repo.repo,
                          run_id: run.id,
                        });

                        const status = runRes.data.status;
                        const conclusion = runRes.data.conclusion;
                        core.info(`Run ${run.id}: status=${status} conclusion=${conclusion}`);

                        if (status === "completed") {
                          core.setOutput("status", status || "completed");
                          core.setOutput("conclusion", conclusion || "unknown");
                          return;
                        }

                        await sleep(15000);
                      }

                      core.setOutput("status", "completed");
                      core.setOutput("conclusion", "timed_out");
                      core.warning(`Timed out waiting for ${workflow_id} run id=${run.id} to complete.`);

            - name: Record downstream run info
              if: ${{ always() }}
              run: |
                  echo "Downstream workflow: ${{ matrix.workflow_file }}"
                  echo "Ref: ${{ steps.dispatch_and_wait.outputs.ref }}"
                  echo "Target SHA: ${{ steps.dispatch_and_wait.outputs.target_sha }}"
                  echo "Run ID: ${{ steps.dispatch_and_wait.outputs.run_id }}"
                  echo "Run URL: ${{ steps.dispatch_and_wait.outputs.run_url }}"
                  echo "Conclusion: ${{ steps.dispatch_and_wait.outputs.conclusion }}"

            - name: Download full downstream logs (zip)
              if: >-
                  ${{
                    always() &&
                    steps.dispatch_and_wait.outputs.run_id != '' &&
                    steps.dispatch_and_wait.outputs.conclusion != 'success'
                  }}
              env:
                  GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
                  RUN_ID: ${{ steps.dispatch_and_wait.outputs.run_id }}
              run: |
                  set -euo pipefail
                  mkdir -p downstream-logs
                  zip_path="downstream-logs/${{ matrix.workflow_file }}-run-${RUN_ID}.zip"
                  echo "Downloading logs for run ${RUN_ID} -> ${zip_path}"
                  curl -sSfL \
                    -H "Authorization: Bearer ${GITHUB_TOKEN}" \
                    -H "Accept: application/vnd.github+json" \
                    "https://api.github.com/repos/${{ github.repository }}/actions/runs/${RUN_ID}/logs" \
                    -o "${zip_path}"

            - name: Upload downstream logs artifact
              if: >-
                  ${{
                    always() &&
                    steps.dispatch_and_wait.outputs.run_id != '' &&
                    steps.dispatch_and_wait.outputs.conclusion != 'success'
                  }}
              uses: actions/upload-artifact@v4
              with:
                  name: downstream-logs-${{ matrix.workflow_file }}-run-${{ steps.dispatch_and_wait.outputs.run_id }}
                  path: downstream-logs/${{ matrix.workflow_file }}-run-${{ steps.dispatch_and_wait.outputs.run_id }}.zip
                  if-no-files-found: error

            - name: Fail this matrix entry if downstream failed
              if: >-
                  ${{
                    steps.dispatch_and_wait.outputs.conclusion != 'success'
                  }}
              run: |
                  echo "Downstream workflow ${{ matrix.workflow_file }} did not succeed."
                  echo "Run URL: ${{ steps.dispatch_and_wait.outputs.run_url }}"
                  echo "Conclusion: ${{ steps.dispatch_and_wait.outputs.conclusion }}"
                  exit 1
