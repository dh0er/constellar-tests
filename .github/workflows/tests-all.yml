name: Run All Tests

on:
    workflow_dispatch:
        inputs:
            ref:
                description: "Branch or tag to run on (default: current ref)"
                required: false
                default: ""
            source_repo:
                description: "Source repo that triggered this workflow (e.g. dh0er/astrologs)"
                required: false
                default: ""
            source_ref:
                description: "Git ref in the source repo to test (e.g. refs/pull/123/merge or refs/heads/main)"
                required: false
                default: ""
            source_sha:
                description: "Commit SHA in the source repo to test (optional)"
                required: false
                default: ""
            source_pr:
                description: "PR number in the source repo (optional)"
                required: false
                default: ""

permissions:
    contents: read
    actions: write

jobs:
    dispatch:
        name: Dispatch all test workflows
        runs-on: ubuntu-latest
        timeout-minutes: 60
        strategy:
            fail-fast: false
            matrix:
                workflow_file:
                    - tests-ios.yml
                    - tests-android.yml
                    - tests-web.yml
                    - tests-macos.yml
                    - tests-windows.yml
                    - tests-linux.yml
        steps:
            - name: Trigger and wait for ${{ matrix.workflow_file }}
              id: dispatch_and_wait
              uses: actions/github-script@v7
              with:
                  github-token: ${{ secrets.GITHUB_TOKEN }}
                  script: |
                      const workflow_id = "${{ matrix.workflow_file }}";
                      const refInput = "${{ inputs.ref }}".trim();
                      const ref = refInput || context.ref.replace(/^refs\/(heads|tags)\//, "");
                      const sourceRepoInput = "${{ inputs.source_repo }}".trim();
                      const sourceRefInput = "${{ inputs.source_ref }}".trim();
                      const sourceShaInput = "${{ inputs.source_sha }}".trim();
                      const sourcePrInput = "${{ inputs.source_pr }}".trim();

                      const dispatchStartedAtMs = Date.now();
                      // Resolve the requested ref to an immutable commit SHA so:
                      // - all dispatched workflows run the exact same commit
                      // - we can reliably discover the created workflow run via head_sha
                      let targetSha = context.sha;
                      if (refInput) {
                        const commit = await github.rest.repos.getCommit({
                          owner: context.repo.owner,
                          repo: context.repo.repo,
                          ref: refInput,
                        });
                        targetSha = commit.data.sha;
                      }

                      // Don't call `users.getAuthenticated()` here: `GITHUB_TOKEN` (integration token)
                      // cannot access GET /user and will fail with "Resource not accessible by integration".
                      const tokenUser = process.env.GITHUB_ACTOR;

                      core.info(`Dispatching ${workflow_id} on ref=${ref} (targetSha=${targetSha}, actor=${tokenUser})`);

                      const dispatchInputs = {
                        ...(sourceRepoInput ? { source_repo: sourceRepoInput } : {}),
                        ...(sourceRefInput ? { source_ref: sourceRefInput } : {}),
                        ...(sourceShaInput ? { source_sha: sourceShaInput } : {}),
                        ...(sourcePrInput ? { source_pr: sourcePrInput } : {}),
                      };

                      // Try to pin the dispatched workflow run to an immutable SHA. If GitHub rejects
                      // the SHA for `ref`, fall back to the branch/tag `ref`.
                      try {
                        await github.rest.actions.createWorkflowDispatch({
                          owner: context.repo.owner,
                          repo: context.repo.repo,
                          workflow_id,
                          ref: targetSha,
                          inputs: dispatchInputs,
                        });
                      } catch (e) {
                        core.warning(`Dispatch with ref=SHA failed for ${workflow_id}; falling back to ref=${ref}. Error: ${e?.message ?? e}`);
                        await github.rest.actions.createWorkflowDispatch({
                          owner: context.repo.owner,
                          repo: context.repo.repo,
                          workflow_id,
                          ref,
                          inputs: dispatchInputs,
                        });
                      }

                      const sleep = (ms) => new Promise((resolve) => setTimeout(resolve, ms));
                      const deadlineMs = dispatchStartedAtMs + (170 * 60 * 1000);
                      const createdAfter = new Date(dispatchStartedAtMs - 60_000);

                      // Find the workflow run that was created by the dispatch.
                      // Note: createWorkflowDispatch does not return the run_id, so we discover it by:
                      // - workflow file name (workflow_id)
                      // - event=workflow_dispatch
                      // - head_sha matches the resolved targetSha (preferred) / head_branch matches ref (fallback)
                      // - created_at after we dispatched (with small slack)
                      // - triggering_actor/actor matches the token user
                      let run = null;
                      while (!run && Date.now() < deadlineMs) {
                        const runs = await github.rest.actions.listWorkflowRuns({
                          owner: context.repo.owner,
                          repo: context.repo.repo,
                          workflow_id,
                          event: "workflow_dispatch",
                          per_page: 50,
                        });

                        const all = (runs.data.workflow_runs || [])
                          .filter((r) => r && new Date(r.created_at) >= createdAfter)
                          .sort((a, b) => new Date(b.created_at) - new Date(a.created_at));

                        const shaCandidates = all.filter((r) => (r.head_sha ?? "") === targetSha);
                        const branchCandidates = all.filter((r) => (r.head_branch ?? "") === ref);
                        const candidates = (shaCandidates.length > 0 ? shaCandidates : branchCandidates);

                        // Prefer matching actor when available.
                        run = candidates.find((r) => {
                          const actor = r.triggering_actor?.login ?? r.actor?.login;
                          return !tokenUser || !actor || actor === tokenUser;
                        }) || candidates[0] || null;

                        if (!run) {
                          core.info(`Waiting for ${workflow_id} run to appear...`);
                          await sleep(5000);
                        }
                      }

                      if (!run) {
                        core.setOutput("workflow_file", workflow_id);
                        core.setOutput("ref", ref);
                        core.setOutput("target_sha", targetSha);
                        core.setOutput("run_id", "");
                        core.setOutput("run_url", "");
                        core.setOutput("conclusion", "timed_out");
                        core.setOutput("status", "completed");
                        core.warning(`Timed out discovering run for ${workflow_id} (ref=${ref}, targetSha=${targetSha}).`);
                        return;
                      }

                      core.info(`Discovered run id=${run.id} url=${run.html_url}`);
                      core.setOutput("workflow_file", workflow_id);
                      core.setOutput("ref", ref);
                      core.setOutput("target_sha", targetSha);
                      core.setOutput("run_id", String(run.id));
                      core.setOutput("run_url", run.html_url);

                      // Wait for it to complete. We do NOT fail this step directly; we capture
                      // status/conclusion as outputs so we can download full logs before failing.
                      while (Date.now() < deadlineMs) {
                        const runRes = await github.rest.actions.getWorkflowRun({
                          owner: context.repo.owner,
                          repo: context.repo.repo,
                          run_id: run.id,
                        });

                        const status = runRes.data.status;
                        const conclusion = runRes.data.conclusion;
                        core.info(`Run ${run.id}: status=${status} conclusion=${conclusion}`);

                        if (status === "completed") {
                          core.setOutput("status", status || "completed");
                          core.setOutput("conclusion", conclusion || "unknown");
                          return;
                        }

                        await sleep(15000);
                      }

                      core.setOutput("status", "completed");
                      core.setOutput("conclusion", "timed_out");
                      core.warning(`Timed out waiting for ${workflow_id} run id=${run.id} to complete.`);

            - name: Record downstream run info
              if: ${{ always() }}
              run: |
                  echo "Downstream workflow: ${{ matrix.workflow_file }}"
                  echo "Ref: ${{ steps.dispatch_and_wait.outputs.ref }}"
                  echo "Target SHA: ${{ steps.dispatch_and_wait.outputs.target_sha }}"
                  echo "Run ID: ${{ steps.dispatch_and_wait.outputs.run_id }}"
                  echo "Run URL: ${{ steps.dispatch_and_wait.outputs.run_url }}"
                  echo "Conclusion: ${{ steps.dispatch_and_wait.outputs.conclusion }}"

            - name: Download full downstream logs (zip)
              if: >-
                  ${{
                    always() &&
                    steps.dispatch_and_wait.outputs.run_id != '' &&
                    steps.dispatch_and_wait.outputs.conclusion != 'success'
                  }}
              env:
                  GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
                  RUN_ID: ${{ steps.dispatch_and_wait.outputs.run_id }}
              run: |
                  set -euo pipefail
                  mkdir -p downstream-logs
                  zip_path="downstream-logs/${{ matrix.workflow_file }}-run-${RUN_ID}.zip"
                  echo "Downloading logs for run ${RUN_ID} -> ${zip_path}"
                  curl -sSfL \
                    -H "Authorization: Bearer ${GITHUB_TOKEN}" \
                    -H "Accept: application/vnd.github+json" \
                    "https://api.github.com/repos/${{ github.repository }}/actions/runs/${RUN_ID}/logs" \
                    -o "${zip_path}"

            - name: Upload downstream logs artifact
              if: >-
                  ${{
                    always() &&
                    steps.dispatch_and_wait.outputs.run_id != '' &&
                    steps.dispatch_and_wait.outputs.conclusion != 'success'
                  }}
              uses: actions/upload-artifact@v4
              with:
                  name: downstream-logs-${{ matrix.workflow_file }}-run-${{ steps.dispatch_and_wait.outputs.run_id }}
                  path: downstream-logs/${{ matrix.workflow_file }}-run-${{ steps.dispatch_and_wait.outputs.run_id }}.zip
                  if-no-files-found: error

            - name: Fail this matrix entry if downstream failed
              if: >-
                  ${{
                    steps.dispatch_and_wait.outputs.conclusion != 'success'
                  }}
              run: |
                  echo "Downstream workflow ${{ matrix.workflow_file }} did not succeed."
                  echo "Run URL: ${{ steps.dispatch_and_wait.outputs.run_url }}"
                  echo "Conclusion: ${{ steps.dispatch_and_wait.outputs.conclusion }}"
                  exit 1
