name: Run All Tests

on:
    workflow_dispatch:
        inputs:
            ref:
                description: "Branch or tag to run on (default: current ref)"
                required: false
                default: ""
            source_repo:
                description: "Source repo that triggered this workflow (e.g. dh0er/astrologs)"
                required: false
                default: ""
            source_ref:
                description: "Git ref in the source repo to test (e.g. refs/pull/123/merge or refs/heads/main)"
                required: false
                default: ""
            source_sha:
                description: "Commit SHA in the source repo to test (optional)"
                required: false
                default: ""
            source_pr:
                description: "PR number in the source repo (optional)"
                required: false
                default: ""

permissions:
    contents: read
    actions: write

jobs:
    dispatch:
        name: Dispatch all test workflows
        runs-on: ubuntu-slim
        timeout-minutes: 60
        strategy:
            fail-fast: false
            matrix:
                workflow_file:
                    - tests-ios.yml
                    - tests-android.yml
                    - tests-web.yml
                    - tests-macos.yml
                    - tests-windows.yml
                    - tests-linux.yml
        steps:
            - name: Trigger and wait for ${{ matrix.workflow_file }}
              uses: actions/github-script@v7
              with:
                  github-token: ${{ secrets.GITHUB_TOKEN }}
                  script: |
                      const workflow_id = "${{ matrix.workflow_file }}";
                      const refInput = "${{ inputs.ref }}".trim();
                      const ref = refInput || context.ref.replace(/^refs\/(heads|tags)\//, "");
                      const sourceRepoInput = "${{ inputs.source_repo }}".trim();
                      const sourceRefInput = "${{ inputs.source_ref }}".trim();
                      const sourceShaInput = "${{ inputs.source_sha }}".trim();
                      const sourcePrInput = "${{ inputs.source_pr }}".trim();

                      const dispatchStartedAtMs = Date.now();
                      // Don't call `users.getAuthenticated()` here: `GITHUB_TOKEN` (integration token)
                      // cannot access GET /user and will fail with "Resource not accessible by integration".
                      const tokenUser = process.env.GITHUB_ACTOR;

                      core.info(`Dispatching ${workflow_id} on ref=${ref} (actor=${tokenUser})`);

                      await github.rest.actions.createWorkflowDispatch({
                        owner: context.repo.owner,
                        repo: context.repo.repo,
                        workflow_id,
                        // IMPORTANT: `ref` must be a branch or tag, not a commit SHA.
                        ref,
                        inputs: {
                          ...(sourceRepoInput ? { source_repo: sourceRepoInput } : {}),
                          ...(sourceRefInput ? { source_ref: sourceRefInput } : {}),
                          ...(sourceShaInput ? { source_sha: sourceShaInput } : {}),
                          ...(sourcePrInput ? { source_pr: sourcePrInput } : {}),
                        },
                      });

                      const sleep = (ms) => new Promise((resolve) => setTimeout(resolve, ms));
                      const deadlineMs = dispatchStartedAtMs + (170 * 60 * 1000);
                      const createdAfter = new Date(dispatchStartedAtMs - 60_000);

                      // Find the workflow run that was created by the dispatch.
                      // Note: createWorkflowDispatch does not return the run_id, so we discover it by:
                      // - workflow file name (workflow_id)
                      // - event=workflow_dispatch
                      // - head_branch matches ref
                      // - created_at after we dispatched (with small slack)
                      // - triggering_actor/actor matches the token user
                      let run = null;
                      while (!run && Date.now() < deadlineMs) {
                        const runs = await github.rest.actions.listWorkflowRuns({
                          owner: context.repo.owner,
                          repo: context.repo.repo,
                          workflow_id,
                          event: "workflow_dispatch",
                          per_page: 50,
                        });

                        const candidates = (runs.data.workflow_runs || [])
                          .filter((r) => r && new Date(r.created_at) >= createdAfter)
                          .filter((r) => (r.head_branch ?? "") === ref)
                          .sort((a, b) => new Date(b.created_at) - new Date(a.created_at));

                        // Prefer matching actor when available.
                        run = candidates.find((r) => {
                          const actor = r.triggering_actor?.login ?? r.actor?.login;
                          return !tokenUser || !actor || actor === tokenUser;
                        }) || candidates[0] || null;

                        if (!run) {
                          core.info(`Waiting for ${workflow_id} run to appear...`);
                          await sleep(5000);
                        }
                      }

                      if (!run) {
                        core.setFailed(`Timed out discovering run for ${workflow_id} (ref=${ref}).`);
                        return;
                      }

                      core.info(`Discovered run id=${run.id} url=${run.html_url}`);

                      // Wait for it to complete and fail this matrix entry if it failed/cancelled.
                      while (Date.now() < deadlineMs) {
                        const runRes = await github.rest.actions.getWorkflowRun({
                          owner: context.repo.owner,
                          repo: context.repo.repo,
                          run_id: run.id,
                        });

                        const status = runRes.data.status;
                        const conclusion = runRes.data.conclusion;
                        core.info(`Run ${run.id}: status=${status} conclusion=${conclusion}`);

                        if (status === "completed") {
                          if (conclusion !== "success") {
                            core.setFailed(`Dispatched workflow ${workflow_id} did not succeed (conclusion=${conclusion}).`);
                          }
                          return;
                        }

                        await sleep(15000);
                      }

                      core.setFailed(`Timed out waiting for ${workflow_id} run id=${run.id} to complete.`);
